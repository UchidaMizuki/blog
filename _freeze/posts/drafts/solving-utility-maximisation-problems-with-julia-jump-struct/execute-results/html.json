{
  "hash": "5a76bf3995ef46550c02e39e81cd3210",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: \"Julia JuMPで効用最大化問題を解いてみた（構造体と多重ディスパッチを使って）\"\nengine: julia\nlang: ja\ncategories: [JuMP, Julia, Japanese]\n# date: \"2025-02-17\"\ndraft: true\n---\n\n::: {#2 .cell execution_count=1}\n``` {.julia .cell-code}\nabstract type AbstractEconomicUtility end\n\nstruct CobbDouglasUtility <: AbstractEconomicUtility\n    efficiency::Float64\n    weights::Vector{Float64}\nend\n\nfunction(f::CobbDouglasUtility)(quantities)\n    return f.efficiency * prod(quantities .^ f.weights)\nend\n```\n:::\n\n\n\n::: {#4 .cell execution_count=1}\n``` {.julia .cell-code}\ncobb_douglas = CobbDouglasUtility(1., [0.3, 0.4, 0.3])\ncobb_douglas([2., 3., 5.])\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3.0963389922845703\n```\n:::\n:::\n\n\n\n::: {#6 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction demand_marshallian(\n  f::CobbDouglasUtility;\n  prices,\n  income\n)\n  return income * f.weights / sum(f.weights) ./ prices\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ndemand_marshallian (generic function with 1 method)\n```\n:::\n:::\n\n\n\n::: {#8 .cell execution_count=1}\n``` {.julia .cell-code}\nquantities_analytical_cobb_douglas = demand_marshallian(\n  cobb_douglas;\n  prices = [1., 2., 3.],\n  income = 100.\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3-element Vector{Float64}:\n 30.0\n 20.0\n 10.0\n```\n:::\n:::\n\n\n\n::: {#10 .cell execution_count=0}\n``` {.julia .cell-code}\nimport Pkg\nPkg.add(\"JuMP\")\nPkg.add(\"Ipopt\")\n```\n:::\n\n\n\n::: {#12 .cell execution_count=1}\n``` {.julia .cell-code}\nusing JuMP\nusing Ipopt\n\nfunction demand_marshallian_numerical(\n  f::AbstractEconomicUtility;\n  prices::Vector{Float64},\n  income::Float64\n)\n    n = length(prices)\n    model = Model(Ipopt.Optimizer) \n    set_silent(model)\n    @variable(model, quantities[1:n] >= 0)\n    @objective(model, Max, f(quantities))\n    @constraint(model, sum(prices .* quantities) <= income)\n    optimize!(model)\n    return value.(quantities)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ndemand_marshallian_numerical (generic function with 1 method)\n```\n:::\n:::\n\n\n\n::: {#14 .cell execution_count=1}\n``` {.julia .cell-code}\nquantities_numerical_cobb_douglas = demand_marshallian_numerical(\n  cobb_douglas;\n  prices = [1., 2., 3.],\n  income = 100.\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n******************************************************************************\nThis program contains Ipopt, a library for large-scale nonlinear optimization.\n Ipopt is released as open source code under the Eclipse Public License (EPL).\n         For more information visit https://github.com/coin-or/Ipopt\n******************************************************************************\n\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3-element Vector{Float64}:\n 30.000000297265977\n 20.00000019590169\n 10.000000099089569\n```\n:::\n:::\n\n\n\n::: {#16 .cell execution_count=1}\n``` {.julia .cell-code}\nstruct CESUtility <: AbstractEconomicUtility\n    substitution::Float64\n    efficiency::Float64\n    weights::Vector{Float64}\nend\n\nfunction(f::CESUtility)(quantities)\n    return f.efficiency * sum(f.weights .* quantities .^ f.substitution) ^ (1 / f.substitution)\nend\n\nfunction demand_marshallian(\n  f::CESUtility;\n  prices,\n  income\n)\n  return f.weights .^ (1 / (1 - f.substitution)) .* prices .^ (1 / (f.substitution - 1)) *\n    income / sum(f.weights .^ (1 / (1 - f.substitution)) .* prices .^ (f.substitution / (f.substitution - 1)))\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ndemand_marshallian (generic function with 2 methods)\n```\n:::\n:::\n\n\n\n::: {#18 .cell execution_count=1}\n``` {.julia .cell-code}\nces = CESUtility(0.5, 1., [0.3, 0.4, 0.3])\nces([2., 3., 5.])\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3.196603520188051\n```\n:::\n:::\n\n\n\n::: {#20 .cell execution_count=1}\n``` {.julia .cell-code}\nquantities_analytical_ces = demand_marshallian(\n  ces;\n  prices = [1., 2., 3.],\n  income = 100.\n)\n\nquantities_numerical_ces = demand_marshallian_numerical(\n  ces;\n  prices = [1., 2., 3.],\n  income = 100.\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3-element Vector{Float64}:\n 45.00000043558224\n 20.000000194987294\n  5.00000005397037\n```\n:::\n:::\n\n\n",
    "supporting": [
      "solving-utility-maximisation-problems-with-julia-jump-struct_files"
    ],
    "filters": [],
    "includes": {}
  }
}