{
  "hash": "9ef4e662fb4e6c40d5c97ee629621312",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Guiding data processing with `adverbial::step_by_step()` in R\"\nlang: en\ncategories: [adverbial, English]\ndate: 2025-05-25\n---\n\n\n\nImplementing the right functions is essential for efficiently sharing data processing knowledge. However, finding the right balance between usability and customization can be challenging.\n\nOne approach to achieving this balance is to break the data processing flow into multiple functions. To ensure the effectiveness of this approach, users must have a clear understanding of the overall workflow.\n\nOne of the advantages of programming, as I see it, is that it allows me to make explicit implicit knowledge that previously had to be accurately understood by humans. This principle inspired the implementation of step-by-step data processing functions in the R adverbial package.\n\nThe step-by-step data processing functionality provided by this package consists mainly of the following three functions.\n\n1.  `step_by_step()` defines a step-by-step data processing workflow.\n2.  `as_step()` converts a function into a step that can be used in the workflow.\n3.  `end_step()` ends a step in the workflow.\n\nThese functions provide a clear framework for data processing, making it easier to share knowledge and collaborate on similarly structured data analysis tasks.\n\n## Example\n\nLet's turn the following data process into a step-by-step data process. This process uses the `penguins` data to calculate the average weight of penguins by island, species and year.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nas_tibble(penguins) |>\n  select(species, island, body_mass, year) |>\n  filter(!is.na(body_mass)) |>\n  mutate(\n    # Convert body_mass to kg\n    body_mass = units::set_units(body_mass, g) |>\n      units::set_units(\"kg\")\n  ) |> \n  summarise(\n    mean_body_mass = mean(body_mass),\n    .by = c(island, species, year)\n  ) |> \n  arrange(island, species, year)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 15 × 4\n   island    species    year mean_body_mass\n   <fct>     <fct>     <int>           [kg]\n 1 Biscoe    Adelie     2007           3.62\n 2 Biscoe    Adelie     2008           3.63\n 3 Biscoe    Adelie     2009           3.86\n 4 Biscoe    Gentoo     2007           5.07\n 5 Biscoe    Gentoo     2008           5.02\n 6 Biscoe    Gentoo     2009           5.14\n 7 Dream     Adelie     2007           3.67\n 8 Dream     Adelie     2008           3.76\n 9 Dream     Adelie     2009           3.65\n10 Dream     Chinstrap  2007           3.69\n11 Dream     Chinstrap  2008           3.8 \n12 Dream     Chinstrap  2009           3.72\n13 Torgersen Adelie     2007           3.76\n14 Torgersen Adelie     2008           3.86\n15 Torgersen Adelie     2009           3.49\n```\n\n\n:::\n:::\n\n\n\n### Defining a step-by-step data processing workflow\n\nThis process can be broken down into the following steps:\n\n1.  Select columns from the data frame with `select()`.\n2.  Filter rows from data frames with `filter()`.\n3.  Mutate columns in the data frame with `mutate()`.\n4.  Summarise the data frame with `summarise()`.\n5.  Order rows in the data frame with `arrange()`.\n\nThus, we can define a step-by-step data processing workflow using the `adverbial` package as follows. Now we can use the `data_wrangler()` to process the data step by step. It shows the steps involved in processing data in the header, making it easier to understand and customise workflows.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(adverbial)\n\ndata_wrangler <- step_by_step(\n  c(\n    select_step = \"Select columns from the data frame\",\n    filter_step = \"Filter rows from data frames\",\n    mutate_step = \"Mutate columns in the data frame\",\n    summarise_step = \"Summarise the data frame\",\n    arrange_step = \"Order rows in the data frame\"\n  )\n)\n\nselect_step <- as_step(mutate, \"select_step\")\nfilter_step <- as_step(filter, \"filter_step\")\nmutate_step <- as_step(mutate, \"mutate_step\")\nsummarise_step <- as_step(summarise, \"summarise_step\")\narrange_step <- as_step(arrange, \"arrange_step\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_wrangler(as_tibble(penguins))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Steps:\n# ☒ 1. select_step:    Select columns from the data frame\n# ☐ 2. filter_step:    Filter rows from data frames\n# ☐ 3. mutate_step:    Mutate columns in the data frame\n# ☐ 4. summarise_step: Summarise the data frame\n# ☐ 5. arrange_step:   Order rows in the data frame\n# ℹ Please call `select_step()` to continue.\n#\n# A tibble: 344 × 8\n   species island    bill_len bill_dep flipper_len body_mass sex     year\n * <fct>   <fct>        <dbl>    <dbl>       <int>     <int> <fct>  <int>\n 1 Adelie  Torgersen     39.1     18.7         181      3750 male    2007\n 2 Adelie  Torgersen     39.5     17.4         186      3800 female  2007\n 3 Adelie  Torgersen     40.3     18           195      3250 female  2007\n 4 Adelie  Torgersen     NA       NA            NA        NA <NA>    2007\n 5 Adelie  Torgersen     36.7     19.3         193      3450 female  2007\n 6 Adelie  Torgersen     39.3     20.6         190      3650 male    2007\n 7 Adelie  Torgersen     38.9     17.8         181      3625 female  2007\n 8 Adelie  Torgersen     39.2     19.6         195      4675 male    2007\n 9 Adelie  Torgersen     34.1     18.1         193      3475 <NA>    2007\n10 Adelie  Torgersen     42       20.2         190      4250 <NA>    2007\n# ℹ 334 more rows\n```\n\n\n:::\n:::\n\n\n\n### Processing data step by step\n\nYou can process the data step by step as follows (up to step 3). You can also use the `as_step()` function to convert any function into a step that can be used in the workflow. If you specify incorrect step names, an error will occur.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_wrangler(as_tibble(penguins)) |> \n  select_step(species, island, body_mass, year) |>\n  filter_step(!is.na(body_mass)) |>\n  mutate_step(\n    # Convert body_mass to kg\n    body_mass = units::set_units(body_mass, g) |>\n      units::set_units(\"kg\")\n  ) |> \n  # You can use another function during the step-by-step process.\n  as_step(head)(n = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Steps:\n# ☒ 1. select_step:    Select columns from the data frame\n# ☒ 2. filter_step:    Filter rows from data frames\n# ☒ 3. mutate_step:    Mutate columns in the data frame\n# ☐ 4. summarise_step: Summarise the data frame\n# ☐ 5. arrange_step:   Order rows in the data frame\n# ℹ Please call `summarise_step()` to continue.\n#\n# A tibble: 3 × 8\n  species island    bill_len bill_dep flipper_len body_mass sex     year\n* <fct>   <fct>        <dbl>    <dbl>       <int>      [kg] <fct>  <int>\n1 Adelie  Torgersen     39.1     18.7         181      3.75 male    2007\n2 Adelie  Torgersen     39.5     17.4         186      3.8  female  2007\n3 Adelie  Torgersen     40.3     18           195      3.25 female  2007\n```\n\n\n:::\n:::\n\n\n\n### Completing the data processing\n\nYou can complete the data processing by adding the remaining steps and ending the workflow with `end_step()`. The following code performs almost the same processing as the original code, the only difference being that it successively informs the user which function to apply next.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_wrangler(as_tibble(penguins)) |> \n  select_step(species, island, body_mass, year) |>\n  filter_step(!is.na(body_mass)) |>\n  mutate_step(\n    # Convert body_mass to kg\n    body_mass = units::set_units(body_mass, g) |>\n      units::set_units(\"kg\")\n  ) |> \n  summarise_step(\n    mean_body_mass = mean(body_mass),\n    .by = c(island, species, year)\n  ) |> \n  arrange_step(island, species, year) |> \n  end_step()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 15 × 4\n   island    species    year mean_body_mass\n * <fct>     <fct>     <int>           [kg]\n 1 Biscoe    Adelie     2007           3.62\n 2 Biscoe    Adelie     2008           3.63\n 3 Biscoe    Adelie     2009           3.86\n 4 Biscoe    Gentoo     2007           5.07\n 5 Biscoe    Gentoo     2008           5.02\n 6 Biscoe    Gentoo     2009           5.14\n 7 Dream     Adelie     2007           3.67\n 8 Dream     Adelie     2008           3.76\n 9 Dream     Adelie     2009           3.65\n10 Dream     Chinstrap  2007           3.69\n11 Dream     Chinstrap  2008           3.8 \n12 Dream     Chinstrap  2009           3.72\n13 Torgersen Adelie     2007           3.76\n14 Torgersen Adelie     2008           3.86\n15 Torgersen Adelie     2009           3.49\n```\n\n\n:::\n:::\n\n\n\n## Conclusion\n\nadverbial package provides a way of breaking down data processing tasks into smaller, more manageable steps. This approach allows users to understand the overall workflow and adapt it to their needs. The aim is to eliminate the need for workers to remember each mentally demanding step of data processing.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}