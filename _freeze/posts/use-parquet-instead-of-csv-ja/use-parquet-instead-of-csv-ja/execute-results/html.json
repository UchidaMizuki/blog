{
  "hash": "ea90f9416dffdcbf6de3f0b753021a9e",
  "result": {
    "markdown": "---\ntitle: \"🗾CSVの代わりにParquetを使ってみよう\"\nlang: ja\ndate: \"2022-06-12\"\ncategories: [parquet, arrow, R, Python, Japanese]\nfig-align: center\nimage: \"https://www.apache.org/logos/res/parquet/parquet.png\"\n---\n\n\n本記事では，**CSVの代替として有望かつビッグデータ分析にも適している[Parquet](https://parquet.apache.org)**を紹介します．\n\nさて，**データフレーム**（Data Frames）は，データ分析において最も基本的なデータ構造の1つです．**Rの[tibble](https://tibble.tidyverse.org)・[dplyr](https://dplyr.tidyverse.org)**や**Pythonの[pandas](https://pandas.pydata.org)**などのデータフレーム操作のためのパッケージを使えば，これまで**Excelなどの表計算ソフトで行っていたデータ分析をさらに効率的に行う**ことができます．\n\nこのようにデータ分析ツールが充実している一方で，データの保存には**Excelなどとの互換性が高いCSV**が未だに広く使われています．しかし，CSVは，必ずしもデータ分析に適したファイル形式とは言えません．そこで，**CSVの代替**として使われることが多くなっているParquetをCSVと比較してみましょう．\n\n## サンプルデータの準備\n\nCSVとParquetを比較するため，まずは，データ分析にありがちなサンプルデータを用意しましょう．今回は，tidyrパッケージで提供されている`who` （[世界保健機関（WHO）結核データ](https://www.who.int/teams/global-tuberculosis-programme/data)）からサンプルデータをつくります．\n\n近年，データ分析では，**整然データ（[tidy data](https://ja.wikipedia.org/wiki/Tidy_data)）**の概念が普及しています．tidy dataは，個々の変数が1つの列をなし，個々の観測（値）が1つの行をなすようなデータです．\n\nそれでは，`who`は，tidy dataと言えるでしょうか？`who`には，`\"new_sp_m014\"` ～`\"newrel_f65\"` といったたくさんの列が存在しますが，これらには，1列ごとに，診断結果（`sp`や`sel`）・性別（`m`と`f`）・年齢階級（`014`や`65`）といった複数の変数が含まれています．そのため，**`who` は，tidy dataでない**といえます．そこで，[こちら](https://tidyr.tidyverse.org/articles/pivot.html)に従って**tidy dataである`who_longer`に変形**します．\n\nデータ分析では，`who` よりtidy dataである`who_longer` のほうを分析が行いやすい一方で，行数は`who`（約7,000行）より`who_longer` （約400,000行）のほうが約50倍多いことがわかります．そのため，tidy dataである`who_longer`のようなデータをテキストファイルであるCSVで保存すると容量が増大してしまいます．\n\nこのように，**tidy dataはデータ分析に適している一方で，CSVのようなテキストファイルでの保存に適していない**ことがわかります．しかし，このような**データ保存上の課題はParquetを使えば解決する**ことができます．\n\nここで，tidy dataでない`who` とtidy dataである`who_longer` を見比べてみましょう．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(fs)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlevels_gender <- c(\"f\", \"m\")\nlevels_age <- c(\"014\", \"1524\", \"2534\", \"3544\", \"4554\", \"5564\", \"65\")\n\nwho_longer <- who |> \n  pivot_longer(cols = new_sp_m014:newrel_f65,\n               names_to = c(\"diagnosis\", \"gender\", \"age\"), \n               names_pattern = \"new_?(.*)_(.)(.*)\",\n               names_transform = list(gender = ~ .x |> \n                                        readr::parse_factor(levels = levels_gender),\n                                      age = ~ .x |> \n                                        readr::parse_factor(levels = levels_age,\n                                                            ordered = TRUE)),\n               values_to = \"count\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# データ整形前\nprint(who, n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7,240 × 60\n  country     iso2  iso3   year new_sp…¹ new_s…² new_s…³ new_s…⁴ new_s…⁵ new_s…⁶\n  <chr>       <chr> <chr> <int>    <int>   <int>   <int>   <int>   <int>   <int>\n1 Afghanistan AF    AFG    1980       NA      NA      NA      NA      NA      NA\n2 Afghanistan AF    AFG    1981       NA      NA      NA      NA      NA      NA\n3 Afghanistan AF    AFG    1982       NA      NA      NA      NA      NA      NA\n4 Afghanistan AF    AFG    1983       NA      NA      NA      NA      NA      NA\n5 Afghanistan AF    AFG    1984       NA      NA      NA      NA      NA      NA\n# … with 7,235 more rows, 50 more variables: new_sp_m65 <int>,\n#   new_sp_f014 <int>, new_sp_f1524 <int>, new_sp_f2534 <int>,\n#   new_sp_f3544 <int>, new_sp_f4554 <int>, new_sp_f5564 <int>,\n#   new_sp_f65 <int>, new_sn_m014 <int>, new_sn_m1524 <int>,\n#   new_sn_m2534 <int>, new_sn_m3544 <int>, new_sn_m4554 <int>,\n#   new_sn_m5564 <int>, new_sn_m65 <int>, new_sn_f014 <int>,\n#   new_sn_f1524 <int>, new_sn_f2534 <int>, new_sn_f3544 <int>, …\n```\n:::\n\n```{.r .cell-code}\n# データ整形後\nprint(who_longer, n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 405,440 × 8\n  country     iso2  iso3   year diagnosis gender age   count\n  <chr>       <chr> <chr> <int> <chr>     <fct>  <ord> <int>\n1 Afghanistan AF    AFG    1980 sp        m      014      NA\n2 Afghanistan AF    AFG    1980 sp        m      1524     NA\n3 Afghanistan AF    AFG    1980 sp        m      2534     NA\n4 Afghanistan AF    AFG    1980 sp        m      3544     NA\n5 Afghanistan AF    AFG    1980 sp        m      4554     NA\n# … with 405,435 more rows\n```\n:::\n:::\n\n\n## CSV・Parquetの保存方法\n\nRでは，`write_csv()` でCSVを保存できます．同様に，arrowパッケージの`write_parquet()` でParquetを保存することができます．`who_longer`をCSVとParquetで保存してみましょう．\n\nCSVとParquetでは，どちらも簡単にデータ保存ができることがわかります．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(arrow)\n\n# CSVを保存\nwrite_csv(who_longer, \"who_longer.csv\")\n\n# Parquetを保存\nwrite_parquet(who_longer, \"who_longer.parquet\")\n```\n:::\n\n\n## Parquetのメリット・CSVとの比較\n\nここからは，保存した`who_longer` のCSV・Parquetファイルを比較して，CSVに対するParquetのメリットを紹介していきます．\n\n### メリット1：CSVよりデータ容量が軽い\n\ntidy dataは行数が多くなるため，CSVでの保存に適しておらず，Parquetを使ったほうがよいことを既に述べました．\n\n実際に，`who_longer` のCSV・Parquetのデータ容量は，それぞれ，14.1 MBと154 KBとなり，**ParquetはCSVの約1 %のデータ容量**しかないことがわかります．\n\nどのようなケースでもこのようなデータ容量の削減が見込めるわけではありませんが，**Parquetは列指向でデータ圧縮**を行うため，Rなどでよく用いられる**tidy dataの保存に適したデータ形式**であるといえます．\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# CSV\nfile_size(\"who_longer.csv\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n14.1M\n```\n:::\n\n```{.r .cell-code}\n# Parquet\nfile_size(\"who_longer.parquet\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n154K\n```\n:::\n\n```{.r .cell-code}\nunits::set_units(file_size(\"who_longer.parquet\") / file_size(\"who_longer.csv\")) |> \n  units::set_units(`%`)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1.071028 [%]\n```\n:::\n:::\n\n\n### メリット2：CSVより読み込みが簡単\n\n`write_csv()`・`write_parquet()` でデータを書き込めるのと同様に，**`read_csv()`・`read_parquet()` でCSV・Parquetデータを読み込む**ことができます．\n\n**CSV**はテキスト形式であるため，**読み込み時に`col_types`で各列の型を指定する必要**があります（デフォルトでは自動で型を推測）．\n\n一方，**Parquet**は，書き込み時に各列の型情報も保存されているため読み込み時に**型を指定する必要がありません**．\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# CSVの読み込み\nread_csv(\"who_longer.csv\",\n         col_types = cols(.default = \"c\",\n                          year = \"i\",\n                          count = \"i\"))\n\n# Parquetの読み込み\nread_parquet(\"who_longer.parquet\")\n```\n:::\n\n\n### メリット3：CSVよりビッグデータの読み込み・集計に適している\n\nCSVはビッグデータの保存に適しておらず，これまでは，ビッグデータの保存にはSQLを用いるなどの使い分けが必要でした．\n\nRでは，dplyr（dbplyr）・DBIなどのパッケージで簡単にSQLが使えますが，データベースへの接続・切断などが必要なSQLは，CSVと使い勝手が異なり，初学者にとってはハードルがあるかもしれません．\n\nまた，（ほとんどの？）**SQLは行指向**であるため，**データの追加・更新・削除などに適しています**が，データ分析に用いられる**データの保存・集計には列指向であるParquetのほうが適している**と思われます．\n\nCSVファイルを用いてビッグデータを集計する場合には，一度，全データをメモリに移す必要があります．そのため，データの読み込みでメモリが逼迫するおそれがあります．\n\nParquetでは，**読み込み時に`as_data_frame = FALSE`**とすることで，SQLと同様に**メモリにデータを移すことなくデータのフィルタリング・集計などが可能**です．\n\nここでは，日本の年・症例別の患者数を計算してみましょう．**dplyrの`filter()` ・`group_by()` ・`summarise()` などを使って効率的にクエリを作成**することができます．**最後に`collect()` を行えばデータフレームを出力**することができます．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_parquet(\"who_longer.parquet\",\n             as_data_frame = FALSE) |> \n  filter(country == \"Japan\",\n         !is.na(count)) |> \n  group_by(country, year, diagnosis) |> \n  summarise(count = sum(count),\n            .groups = \"drop\") |> \n  collect()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 33 × 4\n   country  year diagnosis count\n   <chr>   <int> <chr>     <int>\n 1 Japan    1995 sp        14367\n 2 Japan    1996 sp        12867\n 3 Japan    1997 sp        13571\n 4 Japan    1998 sp        11935\n 5 Japan    1999 sp        12909\n 6 Japan    2000 sp        11853\n 7 Japan    2001 sp        11408\n 8 Japan    2002 sp        10807\n 9 Japan    2003 sp        10843\n10 Japan    2004 sp        10471\n# … with 23 more rows\n```\n:::\n:::\n\n\n### メリット4：複数のデータからなるデータセットを扱える\n\nParquetは列指向であるため，行指向であるSQLと違い，データの追加・更新・削除などに適していません．しかし，**Parquetでは，複数のデータからなるデータセットの読み込みが簡単に行える**ため，このようなデメリットを簡単に解決することができます．\n\nここでは，`who_longer`を年齢階級別に分割したParquetファイルを格納した`\"who_longer_byage\"` フォルダをデータセットのサンプルとして用いましょう．\n\n**`open_dataset(\"who_longer_byage\")`** とすることで，複数のParquetファイルを含むにもかかわらず，さきほどと同様の**データ集計を簡単に行うことができます**．\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ndir_create(\"who_longer_byage\")\nwho_longer |> \n  group_by(age) |> \n  group_walk(~ .x |> \n               write_parquet(str_glue(\"who_longer_byage/who_longer_{.y$age}.parquet\")),\n  .keep = TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nopen_dataset(\"who_longer_byage\") |> \n  filter(country == \"Japan\",\n         !is.na(count)) |> \n  group_by(country, year, diagnosis) |> \n  summarise(count = sum(count),\n            .groups = \"drop\") |> \n  collect()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 33 × 4\n   country  year diagnosis count\n   <chr>   <int> <chr>     <int>\n 1 Japan    1995 sp        14367\n 2 Japan    1996 sp        12867\n 3 Japan    1997 sp        13571\n 4 Japan    1998 sp        11935\n 5 Japan    1999 sp        12909\n 6 Japan    2000 sp        11853\n 7 Japan    2001 sp        11408\n 8 Japan    2002 sp        10807\n 9 Japan    2003 sp        10843\n10 Japan    2004 sp        10471\n# … with 23 more rows\n```\n:::\n:::\n\n\n### メリット5：R・Python間でのデータのやり取りに適している\n\nPythonのpandasパッケージはParquetの読み書きに対応しているため，Parquetは，R・Python間でのデータのやり取りにも適しています．\n\nRで作成した`'who_longer.parquet'` をpandasで読み込んでみましょう．\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\n\npd.read_parquet('who_longer.parquet')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            country iso2 iso3  year diagnosis gender   age   count\n0       Afghanistan   AF  AFG  1980        sp      m   014     NaN\n1       Afghanistan   AF  AFG  1980        sp      m  1524     NaN\n2       Afghanistan   AF  AFG  1980        sp      m  2534     NaN\n3       Afghanistan   AF  AFG  1980        sp      m  3544     NaN\n4       Afghanistan   AF  AFG  1980        sp      m  4554     NaN\n...             ...  ...  ...   ...       ...    ...   ...     ...\n405435     Zimbabwe   ZW  ZWE  2013       rel      f  2534  4649.0\n405436     Zimbabwe   ZW  ZWE  2013       rel      f  3544  3526.0\n405437     Zimbabwe   ZW  ZWE  2013       rel      f  4554  1453.0\n405438     Zimbabwe   ZW  ZWE  2013       rel      f  5564   811.0\n405439     Zimbabwe   ZW  ZWE  2013       rel      f    65   725.0\n\n[405440 rows x 8 columns]\n```\n:::\n:::\n\n\n## まとめ\n\nここまで，R・Pythonで利用可能なParquetのメリットを紹介しました．Parquetは，近年，データ分析で普及しているtidy dataの保存・集計に適しています．\n\nまた，最近では，地理データを扱えるsfパッケージのデータをparquetとして保存できる[sfarrow](https://wcjochem.github.io/sfarrow/)なども登場しています．\n\nCSVの代わりにParquetを用いることでデータ分析がさらに簡単になることが期待されます．\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}